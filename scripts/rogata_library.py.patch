# Patch generated by Pyment v0.3.3

--- a/rogata_library.py
+++ b/rogata_library.py
@@ -6,10 +6,10 @@
 from geometry_msgs.msg import Pose2D
 
 class game_object:
-    """
-    A class defining the most basic game objects of the engine
-
+    """A class defining the most basic game objects of the engine
+    
     ...
+
 
     Attributes
     ----------
@@ -19,7 +19,6 @@
         array containing all borders of the object
     holes : array
         array specifying witch border constitues a hole and which an outer border
-
     Methods
     -------
     is_inside(point)
@@ -56,19 +55,15 @@
 
     def is_inside(self,point):
         """Checks wheter a point is inside the area of the object
-
+        
         A point directl on the border is also considered inside
 
-        Parameters
-        ---------
-        point : numpy array
-            A 2D point which is to be checked
-
-        
-        Returns
-        -------
-        bool 
-            a truthvalue indicating wheter or not the point  is inside the game object 
+        :param point: A 2D point which is to be checked
+        :type point: numpy array
+        :returns: a truthvalue indicating wheter or not the point  is inside the game object
+        :rtype: bool
+
+        
         """
 
 
@@ -98,18 +93,15 @@
 
     def shortest_distance(self,point):
         """calculates the shortest distance between the point and the border of the object
-
+        
         Also returns a positive distance when inside the object
 
-        Parameters
-        ---------
-        point : numpy array
-            A 2D point which is to be checked
-
-        Returns
-        -------
-        scalar
-            distance to border of the object
+        :param point: A 2D point which is to be checked
+        :type point: numpy array
+        :returns: distance to border of the object
+        :rtype: scalar
+
+        
         """
 
         point=tuple(point)
@@ -120,27 +112,23 @@
 
     def line_intersect(self,start,direction,length,iterations=100,precision=0.001):
         """calculates the intersection between a line and the border of the object
-
+        
         Iterations and precision are kept at standart values if non are provided
-        
-        Parameters
-        ----------
-        start : numpy array
-            a 2D point which specifies the start of the line
-        direction : numpy array
-            a normalized vector specifiying the direction of the line
-        length : scalar
-            a scalar specifiying the maximum length of the line
-        iterations : scalar
-            the number of iterations for the ray marching algorithm used
-        precision : scalar
-            the precision with which the intersection is being calculated
-
-        Returns
-        -------
-        numpy array
-            2D position of the intersection
-
+
+        :param start: a 2D point which specifies the start of the line
+        :type start: numpy array
+        :param direction: a normalized vector specifiying the direction of the line
+        :type direction: numpy array
+        :param length: a scalar specifiying the maximum length of the line
+        :type length: scalar
+        :param iterations: the number of iterations for the ray marching algorithm used (Default value = 100)
+        :type iterations: scalar
+        :param precision: the precision with which the intersection is being calculated (Default value = 0.001)
+        :type precision: scalar
+        :returns: 2D position of the intersection
+        :rtype: numpy array
+
+        
         """
         position = start
         default  = start+length*direction/np.linalg.norm(direction)
@@ -158,14 +146,16 @@
 
     def get_position(self):
         """returns the position of the objects center
-
+        
         The center in this case refers to the mean position of the object.
         For a disjointed area this center can be outside of the object itself.
 
-        Returns
-        -------
-        numpy array
-            2D position of the objects center
+
+        :returns: 2D position of the objects center
+
+        :rtype: numpy array
+
+        
         """
         cx   = 0
         cy   = 0
@@ -180,12 +170,12 @@
     def move_object(self,new_pos,rotate=0):
         """moves the object to a new position and orientation
 
-        Parameters
-        ----------
-        new_pos : numpy array
-            new 2D position of the object
-        rotate : scalar
-            angle of rotation
+        :param new_pos: new 2D position of the object
+        :type new_pos: numpy array
+        :param rotate: angle of rotation (Default value = 0)
+        :type rotate: scalar
+
+        
         """
         current_center   = self.get_position()
         for i in range(len(self.area)):
@@ -194,17 +184,18 @@
             self.area[i]=centered_contour+new_pos
 
 class dynamic_object(game_object):
+    """ """
     def __init__(self,name,position,hitbox):
         #have marker ID OR Color, use move_object function to move
         return 0
 
 
 class scene():
-    """
-    A class implemennting scene objects comprised of multiple game_objects.
+    """A class implemennting scene objects comprised of multiple game_objects.
     It offers communication interfaces which can be used by other ROS nodes.
-
+    
     ...
+
 
     Attributes
     ----------
@@ -238,11 +229,21 @@
 
 
     def handle_set_position(self,request):
+        """
+
+        :param request: 
+
+        """
         choosen_object = self.game_objects[request.object]
         pos            = self.game_objects[choosen_object].set_position()
         return SetPosResponse(1)
 
     def handle_line_intersect(self,request):
+        """
+
+        :param request: 
+
+        """
         choosen_object = self.game_objects[request.object]
         origin         = np.array([request.line.x,request.line.y])
         direction      = np.array([np.cos(request.line.theta),np.sin(request.line.theta)])
@@ -251,12 +252,22 @@
         return RequestInterResponse(intersect[0],intersect[1])
 
     def handle_get_distance(self,request):
+        """
+
+        :param request: 
+
+        """
         choosen_object = self.game_objects[request.object]
         point          = np.array([reqest.x,request.y])
         dist           = self.game_objects[choosen_object].shortest_distance(point)
         return RequestDistResponse(dist)
 
     def handle_inside_check(self,request):
+        """
+
+        :param request: 
+
+        """
         choosen_object = self.game_objects[request.object]
         point          = np.array([request.x,request.y])
         inside         = bool(choosen_object.is_inside(point))
@@ -264,16 +275,15 @@
 
    
 class rogata_helper():
-    """
-    A class for people unfarmiliar with ROS.
+    """A class for people unfarmiliar with ROS.
     It abstracts the ROS service calls, into simple class function calls.
-
+    
     ...
+
 
     Attributes
     ----------
     available_objects : list
-
     Methods
     -------
     set_pos(game_object)
@@ -295,22 +305,47 @@
         self.abstract_check_inside   = rospy.ServiceProxy('check_inside',CheckInside,self.inside)
 
     def set_pos(self,game_object):
+        """
+
+        :param game_object: 
+
+        """
         req  = SetPosRequest(game_object)
         resp = self.abstract_get_position(req)
         return resp
 
     def intersect(self,game_object,start_point,direction,length):
+        """
+
+        :param game_object: 
+        :param start_point: 
+        :param direction: 
+        :param length: 
+
+        """
         line = Pose2D(start_point[0],start_point[1],direction)
         req  = RequestInterRequest(game_object,line,length)
         resp = self.abstract_line_intersect(req)
         return np.array([resp.x,resp.y])
 
     def dist(self,game_object,position):
+        """
+
+        :param game_object: 
+        :param position: 
+
+        """
         req  = RequestDistRequest(game_object,position[0],position[1])
         resp = self.abstract_get_distance(req)
         return resp.distance
 
     def inside(self,game_object,point):
+        """
+
+        :param game_object: 
+        :param point: 
+
+        """
         req  = CheckInsideRequest(game_object,point[0],point[1])
         resp = self.abstract_check_inside(req)
         return resp.inside
@@ -321,27 +356,24 @@
 
 def detect_area(hsv_img,lower_color,upper_color,marker_id,min_size,draw=False):
     """Detects the contour of an object containing a marker based on color
-
+    
     It always returns the smallest contour which still contains the marker
     The contour is detected using an image with hsv color space to be robust under different lighting conditions.
     If draw=True the systems draws all found contours as well as the current smalles one containing the marker onto hsv_img
-    
-
-    Parameters
-    ----------
-    hsv_image : numpy array
-        a Image in hsv color space in which the contours  should be detected
-    lower_color : numpy array
-        a 3x1 array containing the lower boundary for the color detection
-    upper_color : numpy array
-        a 3x1 array containing the upper boundary for the color detection
-    marker_id : scalar
-        the ID of a 4x4 aruco marker which identifies the object
-
-
-    Returns
-    -------
-
+
+    :param hsv_image: a Image in hsv color space in which the contours  should be detected
+    :type hsv_image: numpy array
+    :param lower_color: a 3x1 array containing the lower boundary for the color detection
+    :type lower_color: numpy array
+    :param upper_color: a 3x1 array containing the upper boundary for the color detection
+    :type upper_color: numpy array
+    :param marker_id: the ID of a 4x4 aruco marker which identifies the object
+    :type marker_id: scalar
+    :param hsv_img: 
+    :param min_size: 
+    :param draw:  (Default value = False)
+
+    
     """
 
     # color detection
